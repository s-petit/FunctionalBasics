package com.spe.functor;import java.util.function.Function;public interface Monad<A, M extends Monad> extends Functor<A, M> {       // <B> Monad<B> bind(final Function<A,Monad<B>> f);    <B> Monad<B, M> bind(Function<? super A, M> mapping);    //<U> Maybe<U> bind(Function<? super T, Maybe<U>> mapping)/*? extends Stream<? extends R>interface Monad<T,M extends Monad<?,?>> extends Functor<T,M> {    M flatMap(Function<T,M> f);}    @Override    <B> Monad<B, Mon> apply(Monad<Function<? super A, ? extends B>, Mon> appFn);*/    //@Override    //default <B> Monad<B, Mon> fmap(Function<? super A, ? extends B> fn) {   //     return apply(pure(fn));  //  }    //  @Override//    public <U> Maybe<U> bind(Function<? super T, Maybe<U>> mapping) {  //      return mapping.apply(mValue);   // }   /* a “bind” operation: M<T> bind T -> M<U> = M<U>    Exemple : intStream.flatmap(x -> Stream.of(x+1)) ou intStream.flatmap(x -> Stream.of(new BigDecimal(x))*///def map[A, B](f : A => B): C[A] => C[B]    //def apply[A, B](f: F[A => B]): F[A] => F[B]    //def bind[A, B] (f : A => M[B]): M[A] => M[B]}